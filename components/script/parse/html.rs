/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#![warn(unrooted_must_root, unused_imports, unused_variable)]

use dom::attr::AttrHelpers;
use dom::bindings::codegen::Bindings::AttrBinding::AttrMethods;
use dom::bindings::codegen::Bindings::NodeBinding::NodeMethods;
use dom::bindings::codegen::InheritTypes::{NodeBase, NodeDerived, NodeCast, TextCast};
use dom::bindings::codegen::InheritTypes::{ElementCast, HTMLScriptElementCast};
use dom::bindings::js::{JS, JSRef, Temporary, OptionalRootable, Root};
use dom::bindings::utils::Reflectable;
use dom::document::{Document, DocumentHelpers};
use dom::element::{AttributeHandlers, ElementHelpers};
use dom::htmlelement::HTMLElement;
use dom::htmlheadingelement::{Heading1, Heading2, Heading3, Heading4, Heading5, Heading6};
use dom::htmlformelement::HTMLFormElement;
use dom::htmlscriptelement::HTMLScriptElementHelpers;
use dom::node::{Node, NodeHelpers, TrustedNodeAddress};
use dom::types::*;
use page::Page;

use encoding::all::UTF_8;
use encoding::types::{Encoding, DecodeReplace};

use servo_net::resource_task::{Load, LoadData, Payload, Done, ResourceTask, load_whole_resource};
use servo_util::atom::Atom;
use servo_util::str::DOMString;
use servo_util::task::spawn_named;
use std::ascii::StrAsciiExt;
use std::mem;
use std::cell::RefCell;
use std::comm::{channel, Sender, Receiver};
use std::default::Default;
use std::str::MaybeOwned;
use url::{Url, UrlParser};
use http::headers::HeaderEnum;
use time;
use html5ever;
use html5ever::Attribute;
use html5ever::tree_builder::{TreeSink, QuirksMode, NodeOrText, AppendNode, AppendText};
use string_cache::atom;

pub struct JSFile {
    pub data: String,
    pub url: Option<Url>,
}

pub type JSResult = Vec<JSFile>;

pub enum HTMLInput {
    InputString(String),
    InputUrl(Url),
}

enum JSMessage {
    JSTaskNewFile(Url),
    JSTaskNewInlineScript(String, Option<Url>),
    JSTaskExit
}

/// Messages generated by the HTML parser upon discovery of additional resources
pub enum HtmlDiscoveryMessage {
    HtmlDiscoveredScript(JSResult)
}

pub struct HtmlParserResult {
    pub discovery_port: Receiver<HtmlDiscoveryMessage>,
}

fn js_script_listener(to_parent: Sender<HtmlDiscoveryMessage>,
                      from_parent: Receiver<JSMessage>,
                      resource_task: ResourceTask) {
    let mut result_vec = vec!();

    loop {
        match from_parent.recv_opt() {
            Ok(JSTaskNewFile(url)) => {
                match load_whole_resource(&resource_task, url.clone()) {
                    Err(_) => {
                        error!("error loading script {:s}", url.serialize());
                    }
                    Ok((metadata, bytes)) => {
                        let decoded = UTF_8.decode(bytes.as_slice(), DecodeReplace).unwrap();
                        result_vec.push(JSFile {
                            data: decoded.to_string(),
                            url: Some(metadata.final_url),
                        });
                    }
                }
            }
            Ok(JSTaskNewInlineScript(data, url)) => {
                result_vec.push(JSFile { data: data, url: url });
            }
            Ok(JSTaskExit) | Err(()) => {
                break;
            }
        }
    }

    assert!(to_parent.send_opt(HtmlDiscoveredScript(result_vec)).is_ok());
}

// Parses an RFC 2616 compliant date/time string, and returns a localized
// date/time string in a format suitable for document.lastModified.
fn parse_last_modified(timestamp: &str) -> String {
    let format = "%m/%d/%Y %H:%M:%S";

    // RFC 822, updated by RFC 1123
    match time::strptime(timestamp, "%a, %d %b %Y %T %Z") {
        Ok(t) => return t.to_local().strftime(format),
        Err(_) => ()
    }

    // RFC 850, obsoleted by RFC 1036
    match time::strptime(timestamp, "%A, %d-%b-%y %T %Z") {
        Ok(t) => return t.to_local().strftime(format),
        Err(_) => ()
    }

    // ANSI C's asctime() format
    match time::strptime(timestamp, "%c") {
        Ok(t) => t.to_local().strftime(format),
        Err(_) => String::from_str("")
    }
}

pub fn build_element_from_tag(ns: Atom, name: Atom, document: JSRef<Document>) -> Temporary<Element> {
    if ns != sns!(HTML) {
        return Element::new(name.as_slice().to_string(), ns, None, document);
    }

    macro_rules! make(
        ($ctor:ident $(, $arg:expr)*) => ({
            let obj = $ctor::new(name.as_slice().to_string(), document $(, $arg)*);
            ElementCast::from_temporary(obj)
        })
    )

    // This is a big match, and the IDs for inline-interned atoms are not very structured.
    // Perhaps we should build a perfect hash from those IDs instead.
    match name {
        satom!("a")          => make!(HTMLAnchorElement),
        satom!("abbr")       => make!(HTMLElement),
        satom!("acronym")    => make!(HTMLElement),
        satom!("address")    => make!(HTMLElement),
        satom!("applet")     => make!(HTMLAppletElement),
        satom!("area")       => make!(HTMLAreaElement),
        satom!("article")    => make!(HTMLElement),
        satom!("aside")      => make!(HTMLElement),
        satom!("audio")      => make!(HTMLAudioElement),
        satom!("b")          => make!(HTMLElement),
        satom!("base")       => make!(HTMLBaseElement),
        satom!("bdi")        => make!(HTMLElement),
        satom!("bdo")        => make!(HTMLElement),
        satom!("bgsound")    => make!(HTMLElement),
        satom!("big")        => make!(HTMLElement),
        satom!("blockquote") => make!(HTMLElement),
        satom!("body")       => make!(HTMLBodyElement),
        satom!("br")         => make!(HTMLBRElement),
        satom!("button")     => make!(HTMLButtonElement),
        satom!("canvas")     => make!(HTMLCanvasElement),
        satom!("caption")    => make!(HTMLTableCaptionElement),
        satom!("center")     => make!(HTMLElement),
        satom!("cite")       => make!(HTMLElement),
        satom!("code")       => make!(HTMLElement),
        satom!("col")        => make!(HTMLTableColElement),
        satom!("colgroup")   => make!(HTMLTableColElement),
        satom!("data")       => make!(HTMLDataElement),
        satom!("datalist")   => make!(HTMLDataListElement),
        satom!("dd")         => make!(HTMLElement),
        satom!("del")        => make!(HTMLModElement),
        satom!("details")    => make!(HTMLElement),
        satom!("dfn")        => make!(HTMLElement),
        satom!("dir")        => make!(HTMLDirectoryElement),
        satom!("div")        => make!(HTMLDivElement),
        satom!("dl")         => make!(HTMLDListElement),
        satom!("dt")         => make!(HTMLElement),
        satom!("em")         => make!(HTMLElement),
        satom!("embed")      => make!(HTMLEmbedElement),
        satom!("fieldset")   => make!(HTMLFieldSetElement),
        satom!("figcaption") => make!(HTMLElement),
        satom!("figure")     => make!(HTMLElement),
        satom!("font")       => make!(HTMLFontElement),
        satom!("footer")     => make!(HTMLElement),
        satom!("form")       => make!(HTMLFormElement),
        satom!("frame")      => make!(HTMLFrameElement),
        satom!("frameset")   => make!(HTMLFrameSetElement),
        satom!("h1")         => make!(HTMLHeadingElement, Heading1),
        satom!("h2")         => make!(HTMLHeadingElement, Heading2),
        satom!("h3")         => make!(HTMLHeadingElement, Heading3),
        satom!("h4")         => make!(HTMLHeadingElement, Heading4),
        satom!("h5")         => make!(HTMLHeadingElement, Heading5),
        satom!("h6")         => make!(HTMLHeadingElement, Heading6),
        satom!("head")       => make!(HTMLHeadElement),
        satom!("header")     => make!(HTMLElement),
        satom!("hgroup")     => make!(HTMLElement),
        satom!("hr")         => make!(HTMLHRElement),
        satom!("html")       => make!(HTMLHtmlElement),
        satom!("i")          => make!(HTMLElement),
        satom!("iframe")     => make!(HTMLIFrameElement),
        satom!("img")        => make!(HTMLImageElement),
        satom!("input")      => make!(HTMLInputElement),
        satom!("ins")        => make!(HTMLModElement),
        satom!("isindex")    => make!(HTMLElement),
        satom!("kbd")        => make!(HTMLElement),
        satom!("label")      => make!(HTMLLabelElement),
        satom!("legend")     => make!(HTMLLegendElement),
        satom!("li")         => make!(HTMLLIElement),
        satom!("link")       => make!(HTMLLinkElement),
        satom!("main")       => make!(HTMLElement),
        satom!("map")        => make!(HTMLMapElement),
        satom!("mark")       => make!(HTMLElement),
        satom!("marquee")    => make!(HTMLElement),
        satom!("meta")       => make!(HTMLMetaElement),
        satom!("meter")      => make!(HTMLMeterElement),
        satom!("nav")        => make!(HTMLElement),
        satom!("nobr")       => make!(HTMLElement),
        satom!("noframes")   => make!(HTMLElement),
        satom!("noscript")   => make!(HTMLElement),
        satom!("object")     => make!(HTMLObjectElement),
        satom!("ol")         => make!(HTMLOListElement),
        satom!("optgroup")   => make!(HTMLOptGroupElement),
        satom!("option")     => make!(HTMLOptionElement),
        satom!("output")     => make!(HTMLOutputElement),
        satom!("p")          => make!(HTMLParagraphElement),
        satom!("param")      => make!(HTMLParamElement),
        satom!("pre")        => make!(HTMLPreElement),
        satom!("progress")   => make!(HTMLProgressElement),
        satom!("q")          => make!(HTMLQuoteElement),
        satom!("rp")         => make!(HTMLElement),
        satom!("rt")         => make!(HTMLElement),
        satom!("ruby")       => make!(HTMLElement),
        satom!("s")          => make!(HTMLElement),
        satom!("samp")       => make!(HTMLElement),
        satom!("script")     => make!(HTMLScriptElement),
        satom!("section")    => make!(HTMLElement),
        satom!("select")     => make!(HTMLSelectElement),
        satom!("small")      => make!(HTMLElement),
        satom!("source")     => make!(HTMLSourceElement),
        satom!("spacer")     => make!(HTMLElement),
        satom!("span")       => make!(HTMLSpanElement),
        satom!("strike")     => make!(HTMLElement),
        satom!("strong")     => make!(HTMLElement),
        satom!("style")      => make!(HTMLStyleElement),
        satom!("sub")        => make!(HTMLElement),
        satom!("summary")    => make!(HTMLElement),
        satom!("sup")        => make!(HTMLElement),
        satom!("table")      => make!(HTMLTableElement),
        satom!("tbody")      => make!(HTMLTableSectionElement),
        satom!("td")         => make!(HTMLTableDataCellElement),
        satom!("template")   => make!(HTMLTemplateElement),
        satom!("textarea")   => make!(HTMLTextAreaElement),
        satom!("th")         => make!(HTMLTableHeaderCellElement),
        satom!("time")       => make!(HTMLTimeElement),
        satom!("title")      => make!(HTMLTitleElement),
        satom!("tr")         => make!(HTMLTableRowElement),
        satom!("tt")         => make!(HTMLElement),
        satom!("track")      => make!(HTMLTrackElement),
        satom!("u")          => make!(HTMLElement),
        satom!("ul")         => make!(HTMLUListElement),
        satom!("var")        => make!(HTMLElement),
        satom!("video")      => make!(HTMLVideoElement),
        satom!("wbr")        => make!(HTMLElement),
        _                    => make!(HTMLUnknownElement),
    }
}

struct Sink<'doc> {
    js_chan: Sender<JSMessage>,
    document: JS<Document>,
}

impl<'doc> Sink<'doc> {
    // FIXME: not needed after we stop relying on AppendChild
    fn get_or_create(&self, child: NodeOrText<TrustedNodeAddress>) -> Temporary<Node> {
        match child {
            AppendNode(n) => Temporary::new(unsafe { JS::from_trusted_node_address(n) }),
            AppendText(t) => {
                let doc = self.document.root();
                let text = Text::new(t, *doc);
                NodeCast::from_temporary(text)
            }
        }
    }
}

// WARNING: The parser holds internal references to nodes, represented by
// TrustedNodeAddress.  These nodes aren't rooted, which is pretty dicey!  It
// only works because we make the same assumption the old libhubbub bindings
// did, which is that JavaScript code (hence garbage collection) can't run
// during a parse.  Once we implement document.write that will become very
// false, and we'll need hooks in html5ever to let the GC trace the parser's
// internal state.

impl<'doc> TreeSink<TrustedNodeAddress> for Sink<'doc> {
    fn get_document(&mut self) -> TrustedNodeAddress {
        let doc = self.document.root();
        let node: JSRef<Node> = NodeCast::from_ref(*doc);
        node.to_trusted_node_address()
    }

    fn same_node(&self, x: TrustedNodeAddress, y: TrustedNodeAddress) -> bool {
        x == y
    }

    fn elem_name(&self, target: TrustedNodeAddress) -> (atom::Atom, atom::Atom) {
        let node: Root<Node> = unsafe { JS::from_trusted_node_address(target).root() };
        let elem: JSRef<Element> = ElementCast::to_ref(*node)
            .expect("tried to get name of non-Element in HTML parsing");
        (elem.get_namespace().atom.clone(), elem.get_local_name().atom.clone())
    }

    fn create_element(&mut self, ns: atom::Atom, name: atom::Atom, attrs: Vec<Attribute>)
            -> TrustedNodeAddress {
        let doc = self.document.root();
        let elem = build_element_from_tag(Atom { atom: ns }, Atom { atom: name }, *doc).root();

        for attr in attrs.into_iter() {
            // FIXME: implement attr namespaces in html5ever
            elem.set_attribute_from_parser(Atom { atom: attr.name.name}, attr.value,
                satom!(""), None);
        }

        let node: JSRef<Node> = NodeCast::from_ref(*elem);
        node.to_trusted_node_address()
    }

    fn create_comment(&mut self, text: String) -> TrustedNodeAddress {
        let doc = self.document.root();
        let comment = Comment::new(text, *doc);
        let node: Root<Node> = NodeCast::from_temporary(comment).root();
        node.to_trusted_node_address()
    }

    fn append_before_sibling(&mut self,
            _sibling: TrustedNodeAddress,
            _new_node: NodeOrText<TrustedNodeAddress>) -> Result<(), NodeOrText<TrustedNodeAddress>> {
        fail!("append_before_sibling not implemented!");
    }

    fn parse_error(&mut self, msg: MaybeOwned<'static>) {
        error!("Parse error: {:s}", msg);
    }

    fn set_quirks_mode(&mut self, mode: QuirksMode) {
        let doc = self.document.root();
        doc.set_quirks_mode(mode);
    }

    fn append(&mut self, parent: TrustedNodeAddress, child: NodeOrText<TrustedNodeAddress>) {
        let parent: Root<Node> = unsafe { JS::from_trusted_node_address(parent).root() };
        let child = self.get_or_create(child).root();

        // FIXME: The AppendChild algorithm is very complicated.  We use it to
        // coalesce text nodes, but instead we should manipulate the DOM
        // directly and not even create text nodes when they would get
        // coalesced.
        assert!(parent.AppendChild(*child).is_ok());
    }

    fn append_doctype_to_document(&mut self, name: String, public_id: String, system_id: String) {
        let doc = self.document.root();
        let doc_node: JSRef<Node> = NodeCast::from_ref(*doc);
        // FIXME: verify that Some("") is correct here
        let doctype = DocumentType::new(name, Some(public_id), Some(system_id), *doc);
        let node: Root<Node> = NodeCast::from_temporary(doctype).root();

        assert!(doc_node.AppendChild(*node).is_ok());
    }

    fn add_attrs_if_missing(&mut self, target: TrustedNodeAddress, attrs: Vec<Attribute>) {
        let node: Root<Node> = unsafe { JS::from_trusted_node_address(target).root() };
        let elem: JSRef<Element> = ElementCast::to_ref(*node)
            .expect("tried to set attrs on non-Element in HTML parsing");
        for attr in attrs.into_iter() {
            // FIXME: implement attr namespaces in html5ever
            elem.set_attribute_from_parser(Atom { atom: attr.name.name }, attr.value,
                satom!(""), None);
        }
    }

    fn remove_from_parent(&mut self, _target: TrustedNodeAddress) {
        error!("remove_from_parent not implemented!");
    }

    fn mark_script_already_started(&mut self, _node: TrustedNodeAddress) {
        error!("mark_script_already_started not implemented!");
    }
}

pub fn parse_html(page: &Page,
                  document: JSRef<Document>,
                  input: HTMLInput,
                  resource_task: ResourceTask)
                  -> HtmlParserResult {
    // Spawn a JS parser to receive JavaScript.
    let (discovery_chan, discovery_port) = channel();
    let resource_task2 = resource_task.clone();
    let js_result_chan = discovery_chan.clone();
    let (js_chan, js_msg_port) = channel();
    spawn_named("parse_html:js", proc() {
        js_script_listener(js_result_chan, js_msg_port, resource_task2.clone());
    });

    let (base_url, load_response) = match input {
        InputUrl(ref url) => {
            // Wait for the LoadResponse so that the parser knows the final URL.
            let (input_chan, input_port) = channel();
            resource_task.send(Load(LoadData::new(url.clone()), input_chan));
            let load_response = input_port.recv();

            debug!("Fetched page; metadata is {:?}", load_response.metadata);

            load_response.metadata.headers.as_ref().map(|headers| {
                let header = headers.iter().find(|h|
                    h.header_name().as_slice().to_ascii_lower() == "last-modified".to_string()
                );

                match header {
                    Some(h) => document.set_last_modified(
                        parse_last_modified(h.header_value().as_slice())),
                    None => {},
                };
            });

            let base_url = load_response.metadata.final_url.clone();

            {
                // Store the final URL before we start parsing, so that DOM routines
                // (e.g. HTMLImageElement::update_image) can resolve relative URLs
                // correctly.
                *page.mut_url() = Some((base_url.clone(), true));
            }

            (Some(base_url), Some(load_response))
        },
        InputString(_) => {
            match *page.url() {
                Some((ref page_url, _)) => (Some(page_url.clone()), None),
                None => (None, None),
            }
        },
    };

    let mut sink = Sink {
        js_chan: js_chan.clone(),
        document: document.unrooted(),
    };

    let opts = Default::default();
    match input {
        InputString(s) => {
            html5ever::parse_to(&mut sink, Some(s).into_iter(), opts);
        }
        InputUrl(url) => {
            let load_response = load_response.unwrap();
            match load_response.metadata.content_type {
                Some((ref t, _)) if t.as_slice().eq_ignore_ascii_case("image") => {
                    let page = format!("<html><body><img src='{:s}' /></body></html>", base_url.as_ref().unwrap().serialize());
                    html5ever::parse_to(&mut sink, Some(page).into_iter(), opts);
                },
                _ => {
                    let iter = load_response.progress_port.iter().flat_map(|msg|
                        match msg {
                            Payload(data) => {
                                // FIXME: use Vec<u8> (html5ever #34)
                                let data = String::from_utf8(data).unwrap();
                                Some(data).into_iter()
                            }
                            Done(Err(err)) => {
                                fail!("Failed to load page URL {:s}, error: {:s}", url.serialize(), err);
                            }
                            Done(Ok(())) => None.into_iter(),
                        });
                    html5ever::parse_to(&mut sink, iter, opts);
                }
            }
        }
    }

    debug!("finished parsing");
    js_chan.send(JSTaskExit);

    HtmlParserResult {
        discovery_port: discovery_port,
    }
}
